#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
@author: earendil

Used for interface with Distance library.
"""
import sys
sys.path.insert(1, '..')
import pickle
from string import split

from libs.tools_airports import get_set, __version__ as distance_version, build_path, build_network_based_on_shapes
from libs.general_tools import date_generation

from utilities import convert_trajectories, write_trajectories_for_tact
from prepare_navpoint_network import prepare_hybrid_network


def name(paras_nav, data_version):
	version = data_version if data_version!=None else distance_version
	path = build_path(paras_nav, version, full=False)
	_name = 'Real'
	for piece in split(split(path, 'Distance/')[1], '/'):
		_name += '_' + piece
	return _name

def paras_strategic(zone='LF', airac=334, starting_date=[2010,5,6], n_days=1, cut_alt=240.,\
	mode='navpoints', data_version=None):

	"""
	Custom paras building for the distance library.
	"""

	paras = {'zone':zone, 'airac': airac, 'starting_date':starting_date, 'n_days':n_days,\
	 'cut_alt':cut_alt, 'mode':mode}
	paras['type_zone'] = 'EXT'		# 'INT' selects only flights which departs and arrives in the zone, 'SEMI' selects those 
						# which departs or arrives (inclusive) and 'EXT' selects all flights. 
	paras['filtre']='Strong'		# See deliverable 1.3 for exact definition. 'Strong' selects the commercial
						# flights in a first approximation.
	paras['timeStart']=[0,0,0]			# hour, minutes, seconds.
	paras['timeEnd']=[23,59,59]
	paras['type_of_deviation']='absolute' 	# 'absolute' computes the value generated by the point. "derivative" compute the derivated with respect to the previous point.
	paras['nodes'] = 'm1'			# types of nodes for building the network (m1 or m3)
	paras['use_database']=False	# Use directly the database without checking if there is a already the data on the disk.
	paras['make_basic']=False		# Compute basic metrics (degree, strength) of the network.
	paras['make_dev']=False		# Compute advanced metrics (number of flights deviated and so on...)
	paras['make_save']=True 		# Save results.
	paras['make_plots']=False	# Make (many) plots. Can be also done with do_plots script afterwards.
	paras['verb']=True			# set to true for more information during the execution.
	paras['use_base_net']=False	# Set to True to compute also the network with all flights and use its metrics to compare 
						# with the metrics of traffic from the trajectories selected by these parameters.
	paras['redo_FxS']= False		# Important only for nav_sec or sec. Putting "True" is safer
	paras['use_DB_for_net']=False # ?
	paras['data_version'] = data_version #'5.7' #Version of network and traffic data that the code tries to load (leave None for current version)
	paras['ext_area']=False		# expand slightly the sectors' boundaries in order to include navpoints
						# which are exactly on the boundary.
	paras['d']=2 				# set to 3 for navpoints if you want a 3d representation of the trajectories.
	paras['direct']=True 		# Set to True for directed network.
	paras['micromode']=False 	# This is used for computing metrics hour by hour.
	paras['step']=1				# same thing, step in hours.
	paras['force']=True			# Set to True if you want to recompute and rewrite results which are already on the
						# disk.
	paras['compress']=True 		# Compress the results for each day.
	
	paras['collapsed']=False		# This is used to collapsed results hour per hour when using micromode. More or less.
	paras['gather_sectors']=False # Not sure what this is (but it's linked to collapsed).
	paras['do_local']=True 		# Used to compute local metrics of frac, etc.
	paras['both']=False			# Compute the network with m1 AND m3 points.
	#password_db = 'c1p0sql'	# Passowrd for database
	#address_db = '147.163.52.108' 	# Ip adress of DB
	paras['password_db'] = '4ksut79f'	# Password for database
	paras['address_db'] = 'localhost' 	# Ip adress of DB

	paras['main_rep'] = '/home/earendil/Documents/ELSA/Distance/'

	cut_alt = float(cut_alt)

	timeStart=paras['starting_date'][:]
	for l in paras['timeStart']:
		timeStart.append(int(l))
	paras['timeStart']=timeStart
	timeEnd=date_generation(paras['starting_date'],paras['n_days'])[-1]   # A CHANGER
	for l in paras['timeEnd']:
		timeEnd.append(int(l))
	paras['timeEnd']=timeEnd

	return paras

def extract_airports_from_traffic(G_nav, flights):
	"""
	This is a function you can pass to the builder (prepare_hybrid_network) in 
	order to infer the airports and pairs from traffic. 
	You can build your own custom function (for instance to restrict to some navpoints/pairs).
	By default, this one extract every possible entry/exit from flights, finding the first node
	(forward and backward) which are in the list of nodes of the network.
	"""

	assert G_nav.type=='nav'
	entry_exit = []
	for f in flights[:]:
		# Find the first node in trajectory which is in the list of nodes of G_nav.
		idx_entry = 0
		while idx_entry<len(f['route_m1t']) and not G_nav.idx_nodes[f['route_m1t'][idx_entry][0]] in G_nav.nodes():
			idx_entry += 1
		if idx_entry==len(f['route_m1t']): 
			flights.remove(f)
			continue
		
		# Find the first node in trajectory which is in the list of nodes of G_nav (backwards).
		idx_exit = -1
		while abs(idx_exit)<len(f['route_m1t']) and not G_nav.idx_nodes[f['route_m1t'][idx_exit][0]] in G_nav.nodes():
			idx_exit -= 1
		if idx_exit==len(f['route_m1t']):
			flights.remove(f)
			continue

		entry_exit.append((G_nav.idx_nodes[f['route_m1t'][idx_entry][0]], G_nav.idx_nodes[f['route_m1t'][idx_exit][0]]))

	airports_nav = list(set([e for ee in entry_exit for e in ee]))

	return flights, airports_nav, entry_exit

def build_net_distance(zone='LF', data_version=None, layer=350., checks=True, show=True, **kwargs_distance):
	from paras_G import paras_G # TODO Change this, this is really bad.

	# Get navpoint network
	paras_nav = paras_strategic(zone=zone, mode='navpoints', data_version=data_version, **kwargs_distance)
	seth = get_set(paras_nav, force = False)
	G_nav, flights_nav = seth.G, seth.flights
	#print "Number of navpoints with degree 0:", len([n for n in G_nav.nodes() if G_nav.degree(n)])
	#print "Number of flights:", len(flights_nav)

	paras_G['net_nav'] = G_nav
	print "Number of nodes in navpoint network:", len(G_nav.nodes())

	# Get sector network
	G_sec, polygons = build_network_based_on_shapes(paras_nav['password_db'], paras_nav['airac'], zone, layer)
	paras_G['net_sec'] = G_sec
	print "Number of nodes in sec network:", len(G_sec.nodes())

	# Get polygons
	paras_G['polygons'] = polygons
	print "Number of polygons:", len(paras_G['polygons'])

	# Select the flights used to build the capacities and weights
	paras_G['flights_selected'] = flights_nav.values()

	# Generate weights (times of travel) based on traffic
	paras_G['generate_weights_from_traffic'] = True

	# Generate capacities based on traffic
	paras_G['generate_capacities_from_traffic'] = True

	# Other parameters
	paras_G['Nfp']=2
	paras_G['small_sec_thr'] = 0
	paras_G['make_entry_exit_points'] = False
	paras_G['make_borders_points'] = False
	paras_G['attach_termination_nodes'] = True
	paras_G['singletons'] = True
	paras_G['expansion'] = 0.1

	# Extract entry/exit from traffic data:
	route = 'route_' + paras_nav['nodes']
	#entry_exit = [(f[route][0][0], f[route][-1][0]) for f in paras_G['flights_selected']]
	#airports = set([e for ee in entry_exit for e in ee])
	#paras_G['airports_nav'] = airports
	paras_G['airports_nav'] = []
	paras_G['function_airports_nav'] = extract_airports_from_traffic
	#paras_G['pairs_nav'] = entry_exit
	paras_G['pairs_nav'] = []

	paras_G['airports_sec'] = None
	paras_G['pairs_sec'] = None

	paras_G['type_of_net'] = 'R'

	# Building name
	paras_G['name'] = name(paras_nav, data_version)

	# if checks:
	# 	try:
	# 		for f in paras_G['flights_selected']:
	# 			for n, alt in f[route]:
	# 				assert n in G_nav.nodes()
	# 	except AssertionError:
	# 		raise Exception("Some nodes in trajectories are missing in the network's nodes.")

	# 	try:
	# 		for a in airports:
	# 			assert a in G_nav.nodes()
	# 	except AssertionError:
	# 		raise Exception("Some airports are missing in the network's nodes.")

	# Make network
	G = prepare_hybrid_network(paras_G, rep = "../networks", show=show)

	return G

def produce_M1_trajs_from_data(zone='LF', data_version=None, put_fake_sectors=False, save_file=None, **kwargs_distance):
	# Get navpoint network
	paras_nav = paras_strategic(zone=zone, mode='navpoints', data_version=data_version, **kwargs_distance)
	seth = get_set(paras_nav, force = False)
	G_nav, flights_nav = seth.G, seth.flights

	trajectories = []
	for f in seth.flights.values():
		#print f['route_m1']
		#print zip(*f['route_m1'])
		#raise Exception()
		points, altitudes = zip(*f['route_m1'])
		if not put_fake_sectors:
			traj = [(G_nav.node[points[i]]['coord'][0]/60., G_nav.node[points[i]]['coord'][1]/60., altitudes[i],\
				 f['route_m1t'][i][1]) for i in range(len(points))]
		else:
			traj = [(G_nav.node[points[i]]['coord'][0]/60., G_nav.node[points[i]]['coord'][1]/60., altitudes[i], \
				 f['route_m1t'][i][1], 0) for i in range(len(points))]
		# else:
		# 	raise Exception("I can't put sectors, not implemented yet.")
		# 	# The problem with the following is that G is not a network from the ABM but from distance.
		# 	traj = [(G_nav.node[points[i]]['coord'][0]/60., G_nav.node[points[i]]['coord'][1]/60., 
		# 			altitudes[i], f['route_m1t'][i][1], G_nav.node[points[i]]['sec']) for i in range(len(points))]
		
		trajectories.append(traj)

	if save_file!=None:
		write_trajectories_for_tact(trajectories, fil=save_file) 

	return trajectories

if __name__=='__main__':
	#build_net_distance(zone='LF', show=True)
	trajectories = produce_M1_trajs_from_data(zone='LF', put_sectors=False)
	for traj in trajectories[:5]:
		print traj
		print

