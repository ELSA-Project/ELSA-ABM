#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
@author: earendil

Used for interface with Distance library.
"""
import sys
sys.path.insert(1, '..')
import pickle
from string import split

from libs.tools_airports import get_set, __version__ as distance_version, build_path, build_network_based_on_shapes
from libs.general_tools import date_generation

from prepare_navpoint_network import prepare_hybrid_network


def paras_strategic(zone='LF', airac=334, starting_date=[2010,5,6], n_days=1, cut_alt=240.,\
	mode='navpoints', data_version=None):

	"""
	Custom paras building for the distance library.
	"""

	paras = {'zone':zone, 'airac': airac, 'starting_date':starting_date, 'n_days':n_days,\
	 'cut_alt':cut_alt, 'mode':mode}
	paras['type_zone'] = 'EXT'		# 'INT' selects only flights which departs and arrives in the zone, 'SEMI' selects those 
						# which departs or arrives (inclusive) and 'EXT' selects all flights. 
	paras['filtre']='Strong'		# See deliverable 1.3 for exact definition. 'Strong' selects the commercial
						# flights in a first approximation.
	paras['timeStart']=[0,0,0]			# hour, minutes, seconds.
	paras['timeEnd']=[23,59,59]
	paras['type_of_deviation']='absolute' 	# 'absolute' computes the value generated by the point. "derivative" compute the derivated with respect to the previous point.
	paras['nodes'] = 'm1'			# types of nodes for building the network (m1 or m3)
	paras['use_database']=False	# Use directly the database without checking if there is a already the data on the disk.
	paras['make_basic']=False		# Compute basic metrics (degree, strength) of the network.
	paras['make_dev']=False		# Compute advanced metrics (number of flights deviated and so on...)
	paras['make_save']=True 		# Save results.
	paras['make_plots']=False	# Make (many) plots. Can be also done with do_plots script afterwards.
	paras['verb']=True			# set to true for more information during the execution.
	paras['use_base_net']=False	# Set to True to compute also the network with all flights and use its metrics to compare 
						# with the metrics of traffic from the trajectories selected by these parameters.
	paras['redo_FxS']= False		# Important only for nav_sec or sec. Putting "True" is safer
	paras['use_DB_for_net']=False # ?
	paras['data_version'] = data_version #'5.7' #Version of network and traffic data that the code tries to load (leave None for current version)
	paras['ext_area']=False		# expand slightly the sectors' boundaries in order to include navpoints
						# which are exactly on the boundary.
	paras['d']=2 				# set to 3 for navpoints if you want a 3d representation of the trajectories.
	paras['direct']=True 		# Set to True for directed network.
	paras['micromode']=False 	# This is used for computing metrics hour by hour.
	paras['step']=1				# same thing, step in hours.
	paras['force']=True			# Set to True if you want to recompute and rewrite results which are already on the
						# disk.
	paras['compress']=True 		# Compress the results for each day.
	
	paras['collapsed']=False		# This is used to collapsed results hour per hour when using micromode. More or less.
	paras['gather_sectors']=False # Not sure what this is (but it's linked to collapsed).
	paras['do_local']=True 		# Used to compute local metrics of frac, etc.
	paras['both']=False			# Compute the network with m1 AND m3 points.
	#password_db = 'c1p0sql'	# Passowrd for database
	#address_db = '147.163.52.108' 	# Ip adress of DB
	paras['password_db'] = '4ksut79f'	# Password for database
	paras['address_db'] = 'localhost' 	# Ip adress of DB

	paras['main_rep'] = '/home/earendil/Documents/ELSA/Distance/'

	cut_alt = float(cut_alt)

	timeStart=paras['starting_date'][:]
	for l in paras['timeStart']:
		timeStart.append(int(l))
	paras['timeStart']=timeStart
	timeEnd=date_generation(paras['starting_date'],paras['n_days'])[-1]   # A CHANGER
	for l in paras['timeEnd']:
		timeEnd.append(int(l))
	paras['timeEnd']=timeEnd

	return paras

def build_net_distance(zone='LF', data_version=None, layer=350., checks=True, show=True, **kwargs_distance):
	from paras_G import paras_G

	# Get navpoint network
	paras_nav = paras_strategic(zone=zone, mode='navpoints', data_version=data_version, **kwargs_distance)
	seth = get_set(paras_nav, force = False)
	G_nav, flights_nav = seth.G, seth.flights
	paras_G['net_nav'] = G_nav
	print "Number of nodes in navpoint network:", len(G_nav.nodes())

	# Get sector network
	G_sec, polygons = build_network_based_on_shapes(paras_nav['password_db'], paras_nav['airac'], zone, layer)
	paras_G['net_sec'] = G_sec
	print "Number of nodes in sec network:", len(G_sec.nodes())

	# Get polygons
	paras_G['polygons'] = polygons
	print "Number of polygons:", len(paras_G['polygons'])

	# Select the flights used to build the capacities and weights
	paras_G['flights_selected'] = flights_nav.values()

	# Generate weights (times of travel) based on traffic
	paras_G['generate_weights_from_traffic'] = True

	# Generate capacities based on traffic
	paras_G['generate_capacities_from_traffic'] = True

	# Other parameters
	paras_G['Nfp']=2
	paras_G['small_sec_thr'] = 0
	paras_G['make_entry_exit_points'] = False
	paras_G['make_borders_points'] = False
	paras_G['attach_termination_nodes'] = True
	paras_G['singletons'] = False
	paras_G['expansion'] = 0.1

	# Extract entry/exit from traffic data:
	route = 'route_' + paras_nav['nodes']
	entry_exit = [(f[route][0][0], f[route][-1][0]) for f in paras_G['flights_selected']]
	airports = set([e for ee in entry_exit for e in ee])
	paras_G['airports_nav'] = airports
	paras_G['airports_sec'] = None
	paras_G['pairs_nav'] = entry_exit
	paras_G['pairs_sec'] = None

	paras_G['type_of_net'] = 'R'

	# Building name
	version = data_version if data_version!=None else distance_version
	path = build_path(paras_nav, version, full=False)
	name = 'Real'
	for piece in split(split(path, 'Distance/')[1], '/'):
		name += '_' + piece
	paras_G['name'] = name

	if checks:
		try:
			for f in paras_G['flights_selected']:
				for n, alt in f[route]:
					assert n in G_nav.nodes()
		except AssertionError:
			raise Exception("Some nodes in trajectories are missing in the network's nodes.")

		try:
			for a in airports:
				assert a in G_nav.nodes()
		except AssertionError:
			raise Exception("Some airports are missing in the network's nodes.")

	# Make network
	G = prepare_hybrid_network(paras_G, rep = "../networks", show=show)

	return G

if __name__=='__main__':
	build_net_distance(zone='LFMM', show=True)

