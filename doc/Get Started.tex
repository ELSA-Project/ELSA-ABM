\documentclass[12pt]{article}

%\usepackage[latin1]{inputenc}
%\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{vmargin}
\usepackage{pdfpages}


%\setmarginsrb{leftmargin}{topmargin}{rightmargin}{bottommargin}{headheight}{headsep}{footheight}{footskip}
\setmarginsrb{3cm}{1.5cm}{2.7cm}{2cm}{0cm}{1.5cm}{1.1cm}{1.5cm}

% Width for images

\graphicspath{{Figures/}}


\begin{document}


\thispagestyle{empty}


\begin{center}
\Large{{\sc  Getting Started with the Elsa Simulator}}
\end{center}

\vspace{-0.3cm}

\hspace{-\parindent}\setlength{\unitlength}{\textwidth}
\begin{picture}(1,0)
\put(0,0){\line(1,0){1}}
\end{picture}

\vspace{0.3cm}

\section{Setup}

First, create a directory where you see fit to host the code. Then download the code either using git (preferred method) or directly downloading the zip.

\subsection{Using git}

git is already installed in several flavours of Ubuntu, Linux Mint, and Fedora. If git is not installed on your system, you can install it for instance using:
\begin{verbatim}
sudo apt-get install git
\end{verbatim}
on a Debian-like system like Ubuntu\footnote{In the following, we will assume that that user has this kind of OS. The code has not been tested with Windows or MacOS, although. We are pretty sure that the code will be broken for the former (because of paths issues), but it may run on the latter. The final release should be compatible with all OS.}. Then run:
\begin{verbatim}
git clone https://github.com/GGurtner/ELSA-ABM.git
\end{verbatim}
in the folder you have created to download the code. git is especially handy if you want to keep the repository updated with new releases and if you want to contribute to the code.

\subsection{Downloading directly}

You can also just download the source code by clicking on ``download zip'' on the main page, then extract it wherever you want.

\subsection{Installing dependencies}

The code is mainly written in Python 2 so you should install it before anything else, using:

\begin{verbatim}
sudo apt-get install python
\end{verbatim}

Then you should make sure that all the dependencies required are installed. The following python modules should be installed:

\begin{itemize}
\item scipy
\item shapely
\item networkx
\item basemap
\item MySQLdb
\item matplotlib
\item descartes
\item scikit-learn
\end{itemize}

On Debian-like system like Ubuntu, you can use the following command to install them all:

\begin{verbatim}
sudo apt-get install python-scipy python-numpy python-shapely 
python-networkx python-mpltoolkits.basemap python-matplotlib 
python-sklearn python-mysqldb
\end{verbatim}

The package `descartes' has to be installed separately using for instance pip:
\begin{verbatim}
sudo pip install descartes
\end{verbatim}

If pip is not installed on your system, you can install it like this:

\begin{verbatim}
sudo apt-get install python-pip 
\end{verbatim}

You will also need the swig package to do the interface between C and Python, which can be installed this way:
\begin{verbatim}
sudo apt-get install swig
\end{verbatim}

\subsection{Make the setup}

Once the source code has been downloaded and dependencies are satisfied, you can run the setup.py in the main folder in command line:

\begin{verbatim}
./setup.py
\end{verbatim}

It will prompt you for path of the directory you want for the results generated by the code. It then compiles the C code, makes the python wrapper for the tactical level and generates the html documentation describing the Python code. Hopefully, the script should not yield any error. If it does, it will most likely be due to some broken dependencies. In any case, you can open a ticket on GitHub to ask for help. 

After that you can run some tests with:
\begin{verbatim}
tests/run_all_tests.py
\end{verbatim}

All tests should be positive. If it is not the case, you can once again open a ticket on GitHub.

\section{Organization of the code}

The code is organized as follows:
\begin{itemize}
\item the \verb|abm_strategic| folder contains an ABM simulating the strategic phase, including a network builder, airlines and flights objects, and a network manager allocating the airspace to the airlines. 
\item the \verb|abm_tactical| folder contains a tactical model including a "mega-controller" with different rules of conflict resolution as well as a "shock generator".
\item the \verb|interface| folder contains very basic functions which allows to easily control the tactical model from Python.
\item the \verb|libs| folder gathers several hand-made libraries.
\item the \verb|scripts| folder contains some handy scripts which can be used as examples to produce results with the model
\item the \verb|tests| folder contains several scripts for unitary and manual tests. 
\item the \verb|doc| folder gathers the documentation, in the form of html files describing the python code and pdf files for small tutorials.
\end{itemize}          

The Strategic model and the Tactical one are fairly independent. One can use them for his/her own purpose by feeding them with the right input. They can also be used conjointly, even if this feature is very basic at the moment. Indeed, the interface is still under construction and should feature more advanced capabilities for the public release (June or July) with a more integrated code.

\section{Using the network generator}
\label{sec:network}

Included in the strategic agent-based model is a tool to build airspaces. The relevant function is called \verb|prepare_hybrid_network| which is present in the file \verb|prepare_navpoint_network.py|. In the following, we call an ``hybrid network'' a Net object (the class is defined in the file simAirSpaceO.py) which has an attribute which is a NavpointNet object (also defined in simAirSpaceO.py). The Net object, let us call it \verb|G|, is the support for all the information concerning the sectors, whereas the NavpointNet object -- \verb|G_nav| -- includes all information related to the navigation point network. The latter can be accessed using \verb|G.G_nav|.

The \verb|prepare_hybrid_network| function is a constructor which returns such an hybrid network. It builds it using some parameters gathered in the dictionary \verb|paras_G|. This dictionary can be built using a file like the template \verb|paras_G.py|. Some explanations are available in the template file concerning the possible options. In particular, one can:
\begin{itemize}
\item Give a networkx Graph which will be taken as input for the construction of the sector network. All data from the original graph should be conserved. The nodes should have a key `coord' which give their coordinates (centroids of the  sectors). If no graph is given in input, the builder can build a artificial network based on a Delaunay triangulation of some random points distributed in the $[0, 1]\times[0, 1]$.
\item Give the boundaries of every sectors in the form of shapely Polygons.
\item Give the capacities of the sectors with a dictionary or give some traffic data to infer the capacities (maximum number of flights in the area in the time-window).
\item Give the time of crossing between navpoints, or provide some data to infer it.
\item Give the list of entry/exit in the area. At the moment, the user cannot use the traffic data to infer it, but this feature will be added in the future. If the user does not provide the entry/exits, it can be picked at random.
\item Give a networkx Graph which will be the base of the NavpointNet object. All data are conserved, unless stated otherwise (if the user decides to generate some new times of crossing for instance). The times of crossing should be stored as keys `weight' on each edge if the user wants to use them. The positions of the navpoints should be should be stored with the key `coord' on each node.
\end{itemize}

The user can directly use prepare\_navpoint\_network.py as a script to generate a network by changing the name of the file from which the parameter dictionary is built:
\begin{verbatim}
from paras_G import paras_G
\end{verbatim}
and then run it:
\begin{verbatim}
./prepare_navpoint_network.py
\end{verbatim}

As an example, the user can directly use the template file paras\_G.py to generate an artificial network. Running directly prepare\_navpoint\_network.py without modification is enough for this.

The output consists in three files: 
\begin{itemize}
\item The network itself in a pickled file\footnote{pickle is a python module able to serialize any python object.}, called for instance Example.pic,
\item an image of the network, called for instance Example.png
\item some very basic statistics on the network (this file could be expanded in the future), called for instance Example\_basic\_stats\_net.txt
\end{itemize}

One can copy the template file and modify it to generate different kinds of network. The inputs needed are all described in the template file. Note that most of them requires pickle files, but it is planned that in the future more formats will be supported, like jason.

\section{Using the strategic ABM}
The strategic layer aims at producing sensible trajectories planned by the air companies in different environments with different behaviors from the airlines. The output is essentially the ``M1 files'', which are the equivalent of the DDR data about planned trajectories.
\\

The main functions concerning the ABM strategic can be loaded via\footnote{Note that this is not likely to override any other loaded functions given the specific names of the functions. The list of the functions loaded can be viewed in the \_\_init\_\_ function in abm\_strategic/}:
\begin{verbatim}
from abm_strategic import *
\end{verbatim}

The main functions are:
\begin{itemize}
\item \verb|do_standard|,
\item \verb|generate_traffic|,
\item \verb|iter_sim|,
\end{itemize}

The \verb|prepare_hybrid_network| is also loaded, as well as other functions concerning the rectification of the trajectories (see section \ref{sec:rectification}).

The first one is a low level function which is essentially doing one simulation of the strategic ABM. The third one is able to sweep some parameters of the ABM, averaging the results of several instances with the same values of parameters. These two functions are made for systematic studies of the strategic ABM and are not suited to the interface with the tactical layer.

On the other hand, the generate\_traffic function provides a better interface and a higher level of control of the ABM, as well as a simplified setup with standard default parameters. It is suited as a generic trajectory generator, usable in particular with the tactical layer. In this tutorial, we only describe this function which includes everything needs to do simple simulations\footnote{Or more complex ones, since a lot of optional capabilities are included there.}.

The function needs an hybrid network to run, that you can build following section \ref{sec:network}. It needs also a parameter file, a template of which you can find in \verb|abm_strategic/paras.py|. The template serves also as example and is used if no parameter dictionary is given as entry. Hence one can very simply use the function like this:
\begin{verbatim}
generate_traffic(G)
\end{verbatim}
with \verb|G| an hybrid network. The file \verb|tests/example/generate_traffic_example.py| can be used as a way of exploring this function. One of the most interactive features is the ability for the user to directly control some parameters in a transparent way. For instance:
\begin{verbatim}
generate_traffic(G, ACtot=1000, days=48*60)
\end{verbatim}
overwrites the number of flights required by the parameter dictionary, setting it to 1000, and simulates two days of data.

The parameters which are not specified has keyword arguments are taken from a configuration file of which a template can be found in \verb|abm_strategic/paras.py|. The setup makes a copy of it as \verb|abm_strategic/my_paras.py|. This also the default path on which the function `generate\_traffic' looks if the path of the config file is not specified (with keyword argument `paras\_file'). So in summary, the user can fully control the function via a configuration file, or use a configuration just as a template and overwrite the parameters via keyword arguments in `generate\_traffic'. The last option is particularly useful and one wants to iterate on different values for a given parameter.

Another important option for the user is using the option \verb|coordinates|. If set to True, the function returns some coordinate-based trajectories instead of some label-based ones. This is in particular important for the tactical ABM which takes as input the former.

The function returns the simulated trajectories but also some statistics about what happened during the strategic allocation so as to keep track of them.

\section{Rectification of the trajectories}
\label{sec:rectification}

\subsection{Description}

The abm\_strategic folder also include some tools to study some new concepts of SESAR, among which the free-route trajectories. In the model, trajectories can be ``rectified'' by moving some points of the trajectories in order to ``straighten'' them. The relevant function is also available by calling:
\begin{verbatim}
from abm_strategic import *
\end{verbatim}
and is named \verb|rectificate_trajectories_network_with_time|. The inputs to this function is a list of trajectories to be modified, the navpoint network on which the trajectories are defined and an efficiency target. The efficiency $E_S$ of a set $S$ of flights is defined by:
$$
E_S = \frac{\sum_S l_b}{\sum_S l_t}
$$
where $l_t$ are the current lengths of the trajectories and $l_b$ are the best ones (straight lines or great circle). This efficiency is always smaller than 1 and is usually around 0.95 in reality, meaning roughly that the trajectories could be shortened by 5\%.

The function returns the straightened trajectories, and can do it in two ways:
\begin{itemize}
\item Either by removing some nodes on the trajectories, keeping always the first and the last points. Afterwards the points are resampled on each trajectory, hence keeping the number of points per trajectory constant (but not the total number of points).
\item Or by moving some points slowly towards the middle of the segment defined by the point before and the point after it.
\end{itemize}
The first procedure is much faster and should be preferred, but uniformize the distribution of points along the trajectories. It is triggered by choosing \verb|True| with the \verb|remove_nodes| keyword.

The function also recomputes automatically the altitudes and times of crossing of the points using a linear interpolation between the point before and the point after.

This function also features some more advanced capabilities, like the possibility of fixing different probabilities of moving different groups of points. This allows to smoothly go from the current scenario to a SESAR scenario where all (planned) trajectories are straight. One can refer to the documentation of the lower level function  \verb|rectificate_trajectories| for more details about this.
\\

As an example, the user can use again the \verb|tests/example/generate_traffic_example.py| file and change uncomment line 30. The file generated will have trajectories almost straight (efficiency equal to 0.99).

\subsection{Caveats}

The user needs to be careful with the rectification of the trajectories. Since it was designed as a hack to use the strategic model in the SESAR scenario (with free-routing), the output of the rectification function IS NOT compliant with the capacities of the sectors. In order to produce straight trajectories compliant with capacities, the users can design the network such a way that the air companies are able to use straight trajectories. For instance, by putting links directly between entries and exits, which will force the air companies to select this trajectory for their shortest paths. This has not been tested though.

\section{Using the Tactical layer}
\label{sec:tactical}
The Tactical layer aims at transforming planned trajectories into ``actual'' trajectories by deconflicting the them by a simulated super-controller. The standard input is an ``M1 file'' whereas the output is an ``M3 file'', similarly to what exists in DDR data.
\\

The code of the Tactical ABM is stored in abm\_tactical folder. In the abm\_tactical/config folder there is the config.cfg that contains the values of most of the parameters.

The tactical layer can be used independently of the other features of the models. It can be directly controlled via command line with the binary or via a python interface, described in \ref{subsec:interface}.

You can directly compile the source code in the following way:

\begin{verbatim}
LC_ALL=C gcc -O3 -c *.c && gcc *.o -o ElsaABM.so -lm
\end{verbatim}
or use the \verb|compile.py| script which is also compiling the files for the python interface. Using the \verb|setup.py| script described at the beginning also calls \verb|compile.py|.

Once the binary \verb|ElsaABM.so| is produced it is possible to execute the simulations:

\begin{verbatim}
./ElsaABM.so M1_file M3_file Config_file,
\end{verbatim}
where \verb|M1_file| is the file containing the trajectories which will serve as input for the model and \verb|M3_file| is the file that will contain the output, i.e. the trajectories deconflicted by the controller.
\\

Using the files provided as examples in the tests/example/ folder, the user can run:
\begin{verbatim}
./ElsaABM.so ../tests/example/M1_example.dat ../tests/example/M3_example.dat
 ../tests/example/config/config.cfg
\end{verbatim}
which should produce the \verb|M3_example_0.dat| file with deconflicted trajectories. 

\subsection{Input-Output File Format}

Either M1 input file and M3 output files have the same format. The first line must contain the number of Flight:
\begin{verbatim}
1475\tNflight
\end{verbatim}
the following lines are the trajectory of each aircraft. In particular the first two positions, separated by a $\backslash t$,  represent respectively the ID, a unique int number that identify the flight, and the number of NVP in the related route. 

The following positions are the nvps of the route. They consist in 5 values, separated by a comma: the horizontal position (latitude and longitude), the Flight Level, the time in the format `2010-05-06 10:20:32', and an integer number that refers to the sector to which the navpoint belongs. 

\subsection{Configuration File}
Most of the parameters are stored in the configuration file. Changing these values do not require to re-compile the code. 

An example of a config file can be found in \verb|abm_tactical/config/|. Each line starting with $\#$ is a comment, whereas all other lines are values. The name of the variable it refers to needs to be written after a '\verb|\t#|'. For instance:
\begin{verbatim}
#This is a comment
24\t#t_w\n
\end{verbatim}
gives $4t_w = 24$. The position of the values in the configuration file does not matter.

Note that the ABM does not perform any consistency checks on the variables. For example if one wants to increase the lookahead $t\_w$, one needs to fix the product $t_w \times t_r \times t_i$ which represents the time-step\footnote{The smaller is this product, the better works the ABM by the way. See deliverable D2.4 included in the doc/ folder, however a small time-step implies a high computational effort. A good choice for the time-step is about 3min.}. These three values are the most crucial ones for the simulations and should be chosen with care. The user can find their descriptions in the deliverable D2.4 included in the doc/ folder.
\\

Most of the values of the configuration file can be changed without too much trouble. The most simple features are tunable with the parameters \verb|nsim| (number of simulations), and \verb|Nm_shock|, (number of shocks), \verb|radius| (radius of the shocks in nautical miles). Other parameters needs some more understanding of the models. See also the caveats section \ref{subsec:caveats}.


\subsection{Additional files}
Other files are required to run the simulations, which are called respectively \verb|temp_nvp.dat|, \verb|shock_tmp.dat|,  \verb|sector_capacities.dat|, and \verb|bound_latlon.dat|. Some examples are stored in the config folder \verb|abm_tactical/config/|. Their paths have to be specified in the config file, in the corresponding entries.\\

The \verb|temp_nvp.dat| consists in a two columns text file with latitude and longitude of the temporary points used for rerouting. The number of temporary nvps used in the simulation is defined via a \#define variable called \verb|NTMP| in mSector.h. A python utility is included in \verb|abm_tactical/generate_temporary_points.py|, called compute\_temporary\_points, to generate to new files with temporary points. This function takes as input the boundaries of the airspace under control (given as a list of coordinates latitude/longitude), the number of points to generate and  where the file should be saved. The user must be careful because the code:
\begin{itemize}
\item does not check if the points are within the ACC. 
\item does not check the number of points matches \verb|NTMP|.
\end{itemize}


The \verb|shock_tmp.dat| has the same format of \verb|temp_nvp.dat| and it contains the centers of the shocks used in the simulations. This also has to be created via an external script, which is not included at the moment in the repository.

The \verb|sector_capacities.dat| has two columns: the first one stores the ID of the sector, the second the related capacity. These label needs to be consistent with the ones present in the M1 file. Note that the user can use the '-1' for navpoints which do not have to be under control. This is more specifically used for the first and the last points of the trajectories (see caveats \ref{subsec:caveats}).

Finally, the file \verb|bound_latlon.dat| contains the boundaries of the airspace as a list of latitudes/longitudes, like the \verb|temp_nvp.dat| file.

\subsection{Define}

Other parameters are defined in the header files. Every time you want to change these parameter you need to recompile the code. For example in mABM.h is defined LS that is the minimum improvement of the trajectory for a direct:
\begin{verbatim}
#define LS 1000
\end{verbatim}

Another useful \#define is DTMP\_P that is the Maximum distance in meters of the selected temporary points for the rerouting operations.

Others \#define do not have associated values. For example:
\begin{verbatim}
#define SINGLE_TOUCH
\end{verbatim}

If you comment this \#define the ABM can perform a multiple modification of the route of the same aircraft in the same time-step if it does not find any solution.

\subsection{Python interface to the Tactical layer}
\label{subsec:interface}

The folder \verb|interface|, and more specifically the file \verb|abm_interface| provides some function to call the C code from python. The most important function is called \verb|do_ABM_tactical| and calls an interface to the code using SWIG. It arguments include the paths to all necessary files, i.e. the input file, the output file, the config file, and all the additional files \verb|temp_nvp.dat|, \verb|shock_tmp.dat| etc.

Another useful function is called \verb|choose_paras| which able to modify a configuration file in a transparent way. The user just needs to indicate the path to the config file to modify, the name of the parameter to change, the new value, and the function will change the value in the file. So one possible workflow using this interface could be:

\begin{verbatim}
from value in values:
    choose_paras(value, name_of_a_parameter)
    do_ABM_tactical(input, output, config)
\end{verbatim} 

This interface is very basic for the moment and will be expanded in the future, in particular by directly passing python lists to the SWIG interface containing all the information relevant about the flights.

As an example, the user can run the file \verb|tests/example/interface_example.py|, which runs the same simulation than the command in the introduction of this section.

\subsection{Caveats}
\label{subsec:caveats}

Here are some potential traps for new users concerning the tactical layer:
\begin{itemize}
\item The time step $t_s$ is the one the most important parameter of the model. It is equal to $t_s = t_i \times t_w\times t_r$:
\begin{enumerate}
\item The time increment $t_i$ is the time resolution for the trajectories. It should be very small (around 8 seconds),
\item The time window $t_w$ represents the time horizon of the controller on which it will compute the future potential conflicts.
\item The time roll $t_r$, which is a fraction of the time window, represents the time after which the controller updates trajectories of the flights.
\end{enumerate}
In particular, a user who would like to increase the time horizon of the controller would need to keep the time-step $t_s = t_i \times t_w\times t_r$ fixed by reducing the time-roll, otherwise different effects will mix up.
\item The life duration of shocks is computed with respect to the time step. Hence changing $t_i$, $t_w$, or $t_r$ will change the duration of the flights.
\item The shocks appear only on 10 flight levels, not on a whole column of air. The variables \verb|shock_f_lvl_min| and \verb|shock_f_lvl_max| do not change this fact. Instead, they are fixing the possible interval of flight levels of apparition of the shocks.
\item The starting and ending dates have to be informed in the config file at the corresponding lines. They need to be consistent with the trajectories provided. 
\end{itemize}

\section{Miscellaneous}

\subsection{Trajectories formats}

There are different formats for trajectories in the code and we use the following abbreviations in the in-code documentation to keep track of them:
\begin{itemize}
\item  \verb|(x, y, z, t)| : trajectories are made of 4-tuples with latitude, longitude, altitude and 
time.
\item \verb|(x, y, z, t, s)| : same with label of sector as fifth element.
\item \verb|(n), t| : trajectories are made of ONE 2-tuple. The first element is a list of labels
of nodes, the second one is the time of entrance, i.e. the time of the first point of the trajectory.
\item \verb|(n, z), t| : same with altitude attached to each point.
\end{itemize}
There are also two formats of time:
\begin{itemize}
\item \verb|t| : a float representing the number of minutes elapsed since the beginning of 
the day (which is stored somewhere else).
\item \verb|tt| : a tuple \verb|(yy, mm, dd, h, m , s)|.
\end{itemize}

\subsection{Visualization}

The code is shipped with several utilities in order to see the results. Two of them are more specifically useful:
\begin{itemize}
\item \verb|draw_network_and_patches| in \verb|libs/general_tools.py| is able to display an hybrid network as well as trajectories using it.
\item \verb|performance_plots.py| includes many possible plotting functions and is easily usable with the strategic, in particular when sweeping parameters. 
\end{itemize}
Other visualization tools will be included in the final release.

\subsection{Paths}
Some paths are automatically inferred from the parameter dictionaries. For instance, the function \verb|build_path| in simulationO.py takes some values of the parameters and builds file name with them. So one can easily override this by changing the function for its own purpose.


\section{Going further}

The description of the models are available in two different deliverable of the ELSA project, the D1.3 and the D2.4 of the extension of ELSA. They describe in details which mechanisms and algorithms are used, what is the modelling framework and so on, as well as the results obtained so far. Note that the strategic description enclosed in D1.3 is a bit out of date, but an updated partial description is included in D2.4 and will be expanded in D2.5 for the final release.

The public release of this code will happen in June-July and will be shipped with a more detailed documentation about the features of the code.

The folder scripts/ contain different scripts that one can modify to suit its needs. They may or may not work with your configuration and data, so they should be considered as starting points for custom pieces of codes.


\section*{Finding some help}
GitHub is a great tool to track bugs and other issues. If you run into trouble, you can open a new ``issue'' on GitHub by clicking on the tab on the right hand side of the main page of the ELSA simulator. We will try to tackle your issues as well as we can.



\end{document} 
